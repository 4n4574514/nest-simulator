---
layout: index
---

[Â« Back to the index](index)

<hr>

# NEST Coding Style Guidelines

In the code review process we want to enforce a consistent coding style to improve readability and maintainability. The article [Why Code Readability Matters](http://blog.ashodnakashian.com/2011/03/code-readability/) gives an intuition about the benefits of readable code. To simplify the process we use different tools that check compliance with our coding style and developers can reduce the workload of the review process by checking compliance of their code on their own.

_Note that older code might not conform to this rules and should be fixed when convenient._

- [Tooling](#tooling)
- [Coding Style](#coding-style)
    * [General Remarks and Resources](#general-remarks-and-resources)
        * [C++ Language Features](#c-language-features)
        * [Language of Comments and Identifiers](#language-of-comments-and-identifiers)
        * [Debugging & Quality Control](#debugging-quality-control)
        * [Compiler](#compiler)
        * [Online Reference Documents](#online-reference-documents)
        * [Books](#books)
    * [Indentation & Formatting & Naming](#indentation-formatting-naming)
        * [Files](#files)
        * [Folders](#folders)
        * [Variables & Class Members](#variables-class-members)
        * [Functions & Class Methods](#functions-class-methods)
        * [Namespaces](#namespaces)
        * [Classes & Structs & Enums](#classes-structs-enums)
        * [Further Indentation & Formatting](#further-indentation-formatting)
    * [Stopwatch example](#stopwatch-example)
- [.clang-format File](#clang-format-file)
- [Vera++ profile nest](#vera-profile-nest)


## Tooling

The code has to compile without warnings (in the default settings of the build infrastructure). We restrict ourselfs to C++03 standard for a larger support of compilers on various cluster systems and supercomputers.

The [clang-format](http://clang.llvm.org/docs/ClangFormat.html) tool is build on the clang compile frontend. It allows to pretty print input files in a configurable manner, and has vim and emacs integration. We supply a [.clang-format](#clang-format-file) configuration file to enforce some parts of the coding style. During the code review process we check that there is no difference between the committed files and the formatted version of the committed files:

    clang-format <committed file> > tmp_out.txt
    diff <committed file> tmp_out.txt > /dev/null
    if [ $? -ne 0 ]; then
      # error
    fi

Developer can benefit from the tool by formatting their changes before issuing a pull request: `clang-format -i <committed file>`.

Get `clang-format`:
Ubuntu:

    apt-get install clang-format-3.5

OS X:

    brew install clang-format

Or consider installing `clang-format` from the [pre-build binaries](http://llvm.org/releases/download.html).

Further we use [vera++](https://bitbucket.org/verateam/vera/wiki/Home), which 'is a programmable tool for verification, analysis and transformation of C++ source code'. It enables further checks for the code complying to the coding guidelines. We provide the [nest](#vera-profile-nest) profile file in the repository (which needs to be copied/ symlinked into `<vera++ home>/lib/vera++/profiles/`). We then check that there are no messages generated by the execution of the following command:

    vera++ -profile nest <committed file>

Get `vera++`:
Ubuntu:

    apt-get install vera++

OS X:

    brew install vera++

Or consider installing `vera++` from the [binary packages](https://bitbucket.org/verateam/vera/wiki/Installation).

Finally, we let [cppcheck](http://cppcheck.sourceforge.net/) statically analyse the committed files and check for severe errors:

    cppcheck --enable=all <committed file>

Get `cppcheck`:
Ubuntu:

    apt-get install cppcheck

OS X:

    brew install cppcheck
    # or
    sudo port install cppcheck

## General Remarks and Resources

### C++ Language Features

1. Use only ISO C++ language features.
1. Prefer ISO C++ library functions over their ISO C library equivalents.
1. Prefer ISO C++ library containers (STL).
1. Prefer C++ headers over their C equivalents.
1. Don't use printf and related functions.
1. Use C++ style cast notation (see [[1]](#books)).
1. Use the const qualifier where appropriate. Use it consistently (see [[5]](#books), chapter 6)!
1. Use namespaces and exceptions.
1. Try to avoid static class members which need a constructor (non POD).

### Language of Comments and Identifiers

1. All comments should be written in English.
1. All identifiers, class and function names should be in English.

### Debugging & Quality Control

Use the assert macro intensively to check program invariants [[9]](#books). Support for a C++ unit-testing framework for fine grain testing of the functionality is planned. Until then create unit-tests with the supplied SLI and Python unit-testing infrastructure.

### Compiler

NEST compiles with any recent version of the [GNU C/C++ Compiler](https://gcc.gnu.org/) `gcc`. Support and limitation for further compilers is described in the [installation][install].

[install]: http://www.nest-initiative.org/Software:Installation

### Online Reference Documents

1. [C++ Reference](http://www.cplusplus.com/reference/)
1. [C++ Wikibooks](https://en.wikibooks.org/wiki/C%2B%2B_Programming)

### Books

We have found the following books to be useful.

1. Stroustrup B (1997) The C++ Programming Language, 3rd Edition, Addison-Wesley
1. Meyers S (1997) Effective C++, 2nd Edition, Addison Wesley
1. Meyers S (1996) More Effective C++, Addison Wesley
1. Coplien J O (1992) Advanced C++ programming styles and idioms, Addison-Wesley
1. Eckle B (1995) Thinking in C++, Prentice Hall
1. Plauger P J, Stepanov A, Lee M, and Musser D R (1998) The Standard Template Library, Comming June 1998, 1. Prentice Hall
1. Plauger P J (1995) The (draft) Standard C++ Library, Prentice Hall
1. Musser D R and Saini A (1996) STL Tutorial and Reference Guide, Addison-Wesley
1. Kernighan B and Ritchie D (1988) The C Programming Language, 2nd Edition, Prentice Hall

## Coding Style

In the following the coding style guidelines are explained by example and some parts are adopted from [Google C++ Style Guide](https://google-styleguide.googlecode.com/svn/trunk/cppguide.html).

### The #define Guard

All header files should have `#define` guards to prevent multiple inclusion. The format of the symbol name should be `<FILE>_H`. The file `iaf_cond_alpha.h` should have the following guard:

    #ifndef IAF_COND_ALPHA_H
    #define IAF_COND_ALPHA_H
    ...
    #endif  // IAF_COND_ALPHA_H

### Order of Includes

Use standard order for readability and to avoid hidden dependencies: Related header, C library, C++ library, other libraries' .h, your project's .h.

NEST's Makefiles add all project specific include paths to the compile commands, thus the file `iaf_cond_alpha.h` should be included as:
`#include "iaf_cond_alpha.h"`

In `iaf_cond_alpha.cpp`, whose main purpose is to implement iaf_cond_alpha.h, order your includes as follows:

1. iaf_cond_alpha.h.
1. C system files.
1. C++ system files.
1. Other libraries' .h files.
1. Your project's .h files.

With the preferred ordering, if iaf_cond_alpha.h omits any necessary includes, the build of iaf_cond_alpha.cpp will break. Thus, this rule ensures that build breaks show up first for the people working on these files, not for innocent people in other packages.

Within each section the includes should be ordered alphabetically.

You should include all the headers that define the symbols you rely upon (except in cases of forward declaration). If you rely on symbols from bar.h, don't count on the fact that you included foo.h which (currently) includes bar.h: include bar.h yourself, unless foo.h explicitly demonstrates its intent to provide you the symbols of bar.h. However, any includes present in the related header do not need to be included again in the related cpp (i.e., foo.cpp can rely on foo.h's includes).

For example, the includes in `<nestdir>/models/iaf_cond_alpha.cpp might look like this:


    #include "iaf_cond_alpha.h"
    
    #include <sys/types.h>
    #include <unistd.h>
    #include <hash_map>
    #include <vector>
    
    #include "config.h"
    #include "foo.h"
    #include "node.h"


#### Exception:

Sometimes, system-specific code needs conditional includes. Such code can put conditional includes after other includes. Of course, keep your system-specific code small and localized. Example:


    #include "iaf_cond_alpha.h"
    
    #include "port.h"  // For LANG_CXX11.
    
    #ifdef LANG_CXX11
    #include <initializer_list>
    #endif  // LANG_CXX11


### Indentation & Formatting & Naming

#### Files

Files are named in `lower_case_under_lined` notation. C/C++ Header files have the extention `.h`. C implementation files have the extension `.c`. C++ implementation files have the extension `.cpp`. The use of `.cc` is deprecated and is only left for compatibility. 

All files in NEST start with a preamble, which contains the filename and the NEST copyright text (see example below).

Lines should not exceed 100 characters (clang-format). Files should not be to long (max. 2000 lines) (vera++:L006). No trailing whitespace (clang-format).

#### Folders

Use `lower_case_under_lined` notation for folder names.

#### Variables & Class Members

In general, use meaningful, non-abbreviated names or follow naming conventions from the neuroscience field, e.g. the membrane potential is `V_m`. Use the `lower_case_under_lined` notation. Private member variables should end with an underscore (`name_`).

Constants should be defined with `enums` and not with `#define`, and use the `UPPER_CASE_UNDER_LINED` notation:

    enum StateVecElems 
    {
      V_M = 0,
      DG_EXC,
      G_EXC,
      DG_INH,
      G_INH,
      STATE_VEC_SIZE
    };

##### Buildin Types

All code for the nest kernel should use the type aliases, defined in `nest.h`. Thus, use `nest::float_t` instead of `float`.

#### Functions & Class Methods

In general, use meaningful, non-abbreviated names or follow naming conventions from the neuroscience field, e.g. the membrane potential is `V_m`. Use the `lower_case_under_lined` notation.

There should be a line-break after the method's return type (implementation only) (clang-format). Parameters of methods should either fit into one line or each parameter is on a separate line (clang-format).

    inline void
    nest::Stopwatch::print( const char* msg,
                            timeunit_t timeunit,
                            std::ostream& os ) const
    {
      // code
    }

#### Namespaces

Use `lower_case_under_lined` notation for namespaces. Do not use `using namespace` statements in header files (vera++:T018). The closing brace of a namespace should be followed by a comment containing the namespace statement. Do not indent the body of namespaces (clang-format).

    namespace example
    {
    // code
    } // namespace example

All symbols for the NEST kernel are declared in the namespace `nest`.

#### Classes & Structs & Enums

Use a `struct` only for passive objects that carry data; everything else is a `class`. Use `CamelCase` notation for naming classes, structs and enums, e.g. `GenericConnBuilderFactory`. Private, nested classes and structs end with an underscore (`State_`).

The access modifier (`public`, `protected`, `private`) in class definitions are not indented (clang-format).

Do not implement methods inside the class definition, but implement small `inline` methods after the class definition and other methods in the corresponding implementation file.

Template class declarations follow the same style as normal class declarations. This applies in particular to inline declarations. The keyword template followed by the list of template parameters appear on a separate line. The < and > in template expressions have one space after and before the sign, respectively, e.g. `std::vector< int >` (clang-format).

    template< typename T >
    class MyClass: public T
    {
    public:
      // code
    private:
      // more code
    };


#### Further Indentation & Formatting

_Avoid committing indentation and formatting changes together with changes in logic. Always commit these changes separately._

As a general rule of thumb, always indent with two spaces (clang-format). Do not use TAB character in any source file (vera++:L002). Always use braces around blocks of code (vera++:T019). The braces of code blocks have their own line (clang-format).

Control structures (`if`, `while`, `for`, ...) have a single space after the keyword (clang-format / vera++:T003, T008). The parenthesis around the tests have a space after the opening and before the closing parenthesis (clang-format). The case labels in `switch` statements are not indented (clang-format).

    if ( x > 0 )
    {
      // code
    }
    else
    {
      // code
    }

    switch ( i )
    {
    case 0:
      // code
    default:
      // code
    }

Binary operators (`+`,`-`,`*`,`||`,`&`,...) are surrounded by one space, e.g. `a + b` (clang-format).

Unary operators have no space between operator and operand, e.g. `-a` (clang-format). Do not use the negation operator `!` since it can easily be overseen. Instead use `not`, e.g. `not vec.empty()` (vera++:T012).

There is no space between a statement and its corresponding semicolon (clang-format):

    return a + 3 ; // bad
    return a + 3;  // good

##### Further checks performed by vera++:

* **F001** Source files should not use the '\r' (CR) character
* **F002** File names should be well-formed
* **L001** No trailing whitespace (clang-format)
* **L003** no leading / ending empty lines
* **L005** not to many (> 2) consecutive empty lines
* **T001** One-line comments should not have forced continuation ( `// ... \`)
* **T002** Reserved names should not be used for preprocessor macros
* **T004** Some keywords should be immediately followed by a colon (clang-format)
* **T005** Keywords break and continue should be immediately followed by a semicolon (clang-format)
* **T006** Keywords return and throw should be immediately followed by a semicolon or a single space (clang-format)
* **T007** Semicolons should not be isolated by spaces or comments from the rest of the code (~ clang-format)
* **T010** Identifiers should not be composed of 'l' and 'O' characters only
* **T017** Unnamed namespaces are not allowed in header files

##### Further transformations performed by clang-format:

* Align Trailing Comments
* Always Break Before Multiline Strings
* Always Break Template Declarations
* Break Constructor Initializers Before Comma
* Pointer Alignment: Left
* Space Before Assignment Operators
* Spaces Before Trailing Comments: 1
* Spaces In Parentheses
* Spaces In Square Brackets

### Stopwatch example

For example, the `stopwatch.h` file could look like:

    /*
     *  stopwatch.h
     *
     *  This file is part of NEST.
     *
     *  Copyright (C) 2004 The NEST Initiative
     *
     *  NEST is free software: you can redistribute it and/or modify
     *  it under the terms of the GNU General Public License as published by
     *  the Free Software Foundation, either version 2 of the License, or
     *  (at your option) any later version.
     *
     *  NEST is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     *  GNU General Public License for more details.
     *
     *  You should have received a copy of the GNU General Public License
     *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
     *
     */
    
    #ifndef STOPWATCH_H
    #define STOPWATCH_H
    
    #include <sys/time.h>

    #include <iostream>
    #include <cassert>
    
    namespace nest
    {
    class Stopwatch
    {
    public:
      typedef size_t timestamp_t;
      typedef size_t timeunit_t;
    
      enum
      {
        MICROSEC = ( timeunit_t ) 1,
        MILLISEC = MICROSEC * 1000,
        SECONDS = MILLISEC * 1000,
        MINUTES = SECONDS * 60,
        HOURS = MINUTES * 60,
        DAYS = HOURS * 24
      };
    
      Stopwatch();
    
      void start();
    
      void stop();
    
      bool isRunning() const;
    
      double elapsed( timeunit_t timeunit = SECONDS ) const;
    
      timestamp_t elapsed_timestamp() const;
    
      void reset();
    
      void print( const char* msg = "",
                  timeunit_t timeunit = SECONDS,
                  std::ostream& os = std::cout ) const;
    
      friend std::ostream& operator<<( std::ostream& os,
                                       const Stopwatch& stopwatch );
    
    private:
      timestamp_t begin_, end_;
      size_t prev_elapsed_;
      bool running_;
    
      static timestamp_t get_timestamp();
    };
    
    inline bool
    Stopwatch::correct_timeunit( timeunit_t t )
    {
      return t == MICROSEC || t == MILLISEC || t == SECONDS || t == MINUTES
             || t == HOURS || t == DAYS;
    }
    
    inline void
    nest::Stopwatch::start()
    {
      if ( not isRunning() )
      {
        prev_elapsed_ += end_ - begin_;  // store prev. time, if we resume
        end_ = begin_ = get_timestamp(); // invariant: end_ >= begin_
        running_ = true;                 // we start running
      }
    }
    
    inline void
    nest::Stopwatch::stop()
    {
      if ( isRunning() )
      {
        end_ = get_timestamp(); // invariant: end_ >= begin_
        running_ = false;       // we stopped running
      }
    }
    
    inline bool
    nest::Stopwatch::isRunning() const
    {
      return running_;
    }
    
    inline double
    nest::Stopwatch::elapsed( timeunit_t timeunit ) const
    {
      assert( correct_timeunit( timeunit ) );
      return 1.0 * elapsed_timestamp() / timeunit;
    }
    
    inline nest::Stopwatch::timestamp_t
    nest::Stopwatch::elapsed_timestamp() const
    {
      if ( isRunning() )
      {
        // get intermediate elapsed time; do not change end_, to be const
        return get_timestamp() - begin_ + prev_elapsed_;
      }
      else
      {
        // stopped before, get time of current measurment + last measurments
        return end_ - begin_ + prev_elapsed_;
      }
    }
    
    inline void
    nest::Stopwatch::reset()
    {
      begin_ = 0; // invariant: end_ >= begin_
      end_ = 0;
      prev_elapsed_ = 0; // erase all prev. measurments
      running_ = false;  // of course not running.
    }
    
    inline void
    nest::Stopwatch::print( const char* msg,
                            timeunit_t timeunit,
                            std::ostream& os ) const
    {
      assert( correct_timeunit( timeunit ) );
      double e = elapsed( timeunit );
      os << msg << e;
      switch ( timeunit )
      {
      case MICROSEC:
        os << " microsec.";
        break;
      case MILLISEC:
        os << " millisec.";
        break;
      case SECONDS:
        os << " sec.";
        break;
      case MINUTES:
        os << " min.";
        break;
      case HOURS:
        os << " h.";
        break;
      case DAYS:
        os << " days.";
        break;
      }
      os << std::endl;
    }
    
    inline nest::Stopwatch::timestamp_t
    nest::Stopwatch::get_timestamp()
    {
      // works with:
      // * hambach (Linux 2.6.32 x86_64)
      // * JuQueen (BG/Q)
      // * MacOS 10.9
      struct timeval now;
      gettimeofday( &now, ( struct timezone* ) 0 );
      return ( nest::Stopwatch::timestamp_t ) now.tv_usec
             + ( nest::Stopwatch::timestamp_t ) now.tv_sec
               * nest::Stopwatch::SECONDS;
    }
    
    } // namespace nest
    #endif // STOPWATCH_H

And the corresponding stopwatch.cpp:

    /*
     *  stopwatch.cpp
     *
     *  This file is part of NEST.
     *
     *  Copyright (C) 2004 The NEST Initiative
     *
     *  NEST is free software: you can redistribute it and/or modify
     *  it under the terms of the GNU General Public License as published by
     *  the Free Software Foundation, either version 2 of the License, or
     *  (at your option) any later version.
     *
     *  NEST is distributed in the hope that it will be useful,
     *  but WITHOUT ANY WARRANTY; without even the implied warranty of
     *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     *  GNU General Public License for more details.
     *
     *  You should have received a copy of the GNU General Public License
     *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
     *
     */
    
    #include "stopwatch.h"
    
    namespace nest
    {
    std::ostream& operator<<( std::ostream& os, const Stopwatch& stopwatch )
    {
      stopwatch.print( "", Stopwatch::SECONDS, os );
      return os;
    }
    }
    
    
    nest::Stopwatch::Stopwatch()
      : begin_( 0 )
      , end_( 0 )
      , prev_elapsed_( 0 )
      , running_( false )
    {
    }

## .clang-format File

Copy as `.clang-format` file into directory, in which you execute the `clang-format` command.

    BasedOnStyle: WebKit
    
    AccessModifierOffset: -2
    AlignEscapedNewlinesLeft: true
    AlignTrailingComments: true
    AllowAllParametersOfDeclarationOnNextLine: false
    AllowShortBlocksOnASingleLine: false
    AllowShortCaseLabelsOnASingleLine: false
    AllowShortFunctionsOnASingleLine: None
    AllowShortIfStatementsOnASingleLine: false
    AllowShortLoopsOnASingleLine: false
    AlwaysBreakAfterDefinitionReturnType: true
    AlwaysBreakBeforeMultilineStrings: true
    AlwaysBreakTemplateDeclarations: true
    
    BinPackArguments: false
    BinPackParameters: false
    BreakBeforeBinaryOperators: NonAssignment
    BreakBeforeBraces: Allman
    BreakBeforeTernaryOperators: true
    BreakConstructorInitializersBeforeComma: true
    
    ColumnLimit: 80
    ConstructorInitializerAllOnOneLineOrOnePerLine: false
    ConstructorInitializerIndentWidth: 2
    ContinuationIndentWidth: 2
    
    DerivePointerAlignment: false
    
    ExperimentalAutoDetectBinPacking: false
    
    IndentCaseLabels: false
    IndentWidth: 2
    IndentWrappedFunctionNames: false
    
    KeepEmptyLinesAtTheStartOfBlocks: true
    
    Language: Cpp
    
    MaxEmptyLinesToKeep: 2
    
    NamespaceIndentation: None
    
    PointerAlignment: Left
    
    SpaceAfterCStyleCast: true
    SpaceBeforeAssignmentOperators: true
    SpaceBeforeParens: ControlStatements
    SpaceInEmptyParentheses: false
    SpacesBeforeTrailingComments: 1
    SpacesInAngles: true
    SpacesInCStyleCastParentheses: true
    SpacesInParentheses: true
    SpacesInSquareBrackets: true
    Standard: Cpp03
    
    UseTab: false


## Vera++ profile nest

Copy as `nest` into `<vera++ home>/lib/vera++/profile`.

    #!/usr/bin/tclsh
    # This profile includes all the rules for checking NEST
    
    set rules {
      F001
      F002
      L001
      L002
      L003
      L005
      L006
      T001
      T002
      T004
      T005
      T006
      T007
      T010
      T011
      T012
      T013
      T017
      T018
      T019
    }
