/*
 *  issue-800.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


 /* BeginDocumentation
    Name: testsuite::issue-800

    Synopsis: (issue-800) run -> NEST exits if test fails

    Description:
    This test ensures that aeif_cond_beta_multisynapse model has recordable
    conductances. It also checks that the recordables can be changed at
    prior to connecting devices, and that the conductance is actually equal
    to a beta function.

    Author: Luciano Paz
    FirstVersion: August 2017
 */
 
(unittest) run
/unittest using

% This test should only run if we have GSL
skip_if_without_gsl
% ---------------------------

M_ERROR setverbosity

% test default recordables include g_1
{
  << >> begin
  ResetKernel
  
  /nrn /aeif_cond_beta_multisynapse Create def
  
  /mm /multimeter << /withtime true /time_in_steps true
                     /interval 1.0 /record_from [ /V_m /w /g_1 ] >> Create def
  
  mm nrn Connect
}
assert_or_die

% test resize recordables
{
  << >> begin
  ResetKernel
  
  /E_rev1        [0.0  0.0  -85.0] def
  /E_rev2        [0.0  0.0] def
  /E_rev3        [0.0  0.0  -85.0 0.] def
  /tau_rise1     [5.0  1.0  25.0] def
  /tau_rise2     [5.0  1.0] def
  /tau_rise3     [5.0  1.0  25.0 50.] def
  /tau_decay1    [20.0  10.0  85.0] def
  /tau_decay2    [20.0  10.0] def
  /tau_decay3    [20.0  10.0  85.0 100.] def
  
  /nrn /aeif_cond_beta_multisynapse <<  
    /E_rev E_rev1 /tau_rise tau_rise1 /tau_decay tau_decay1
      >> Create def
  /len1 1 GetStatus /recordables get length def
  
  1 << /E_rev E_rev2 /tau_rise tau_rise2 /tau_decay tau_decay2 >> SetStatus
  /len2 1 GetStatus /recordables get length def
  
  1 << /E_rev E_rev3 /tau_rise tau_rise3 /tau_decay tau_decay3 >> SetStatus
  /len3 1 GetStatus /recordables get length def
  
  len1 5 eq len2 4 eq and len3 6 eq and
}
assert_or_die

% test record g and check for beta function synapse
{
  << >> begin
  ResetKernel
  /E_rev       [0.0  0.0  -85.0 20.] def % synaptic reversal potentials  
  /tau_decay   [40.0 20.0  30.0 25.] def % synaptic decay times  
  /tau_rise    [20.0 10.0  5.0  25.] def % synaptic rise times  
  /weights     [1.0  0.5   2.0  1.0] def % synaptic weights
  /delays      [1.0  3.0   10.0 10.] def % ms - synaptic delays
  /spike_time  10.  def    % time at which the single spike occurs
  /dt          0.1  def    % time step
  /total_t     500. def    % total simulation time
  /tolerance   1e-7 def    % tolerable difference between theoretic and simulated beta synapse conductances

  /alpha_function
  {
    % Call like t0 W tau t alpha_function
    << /tau 1.0 /W 1.0 /t0 0. >>
    begin
      /t exch def
      /tau exch def
      /W exch def
      /t0 exch def
      
      t
      {
        /tt exch def
        tt t0 geq
        {
          /tdiff_over_tau tt t0 sub tau div def
          tdiff_over_tau neg exp E tdiff_over_tau W mul mul mul
        }
        % else
        {
          0.
        } ifelse
      } Map
    end
  } def

  /beta_function
  {
    % Call like t0 W tau_decay tau_rise t beta_function
    << /tau1 1.0 /tau2 2.0 /W 1.0 /t0 0. >>
    begin
      /t exch def
      /tau1 exch def
      /tau2 exch def
      /W exch def
      /t0 exch def
      
      tau1 tau2 eq
      { % Compute alpha function
        t0 W tau1 t alpha_function
      }
      % else
      { % Compute beta function
        /tau1_inv tau1 inv def
        /tau2_inv tau2 inv def
        /inv_tau_diff tau1_inv tau2_inv sub def
        /tpeak tau2 tau1 div ln inv_tau_diff div def
        /den tpeak tau1 div neg exp tpeak tau2 div neg exp sub def
        
        t
        {
          /tt exch def
          tt t0 geq
          {
            /tdiff tt t0 sub def
            /num tdiff tau1 div neg exp tdiff tau2 div neg exp sub def
            W num mul den div
          }
          % else
          {
            0.
          } ifelse
        } Map
      } ifelse
    end
  } def

  0 << /resolution dt >> SetStatus

  % Create a spike generator that generates a single spike
  /spike_generator Create /sg Set
  sg << /spike_times [spike_time] >> SetStatus % generates a single peak

  % Create the multisynapse neuron
  /nrn /aeif_cond_beta_multisynapse 
    <<  /w 0. /a 0. /b 0. /Delta_T 0. /t_ref 0. /I_e 0.
        /E_rev E_rev /tau_decay tau_decay /tau_rise tau_rise
    >> Create def

  % Create an array of synaptic indexes to loop through 
  delays length 1 arraystore Range /synapses_idx exch def
  [delays weights synapses_idx] % loop on synaptic receptor ports
  {
    /syn_id exch def
    /W exch def
    /delay exch def
    % Connect spike generator to each port
    [sg] [nrn] /one_to_one <<
      /model /static_synapse
      /delay delay
      /weight W
      /receptor_type syn_id >>
      Connect
  } ScanThread

  % Create the multimeter that will record from the 3 conductance channels
  /mm /multimeter << /withtime true /time_in_steps true
                     /interval dt /record_from [ /g_1 /g_2 /g_3 /g_4 ] >> Create def

  mm nrn Connect

  % Simulate
  total_t Simulate

  % Get the conductances measured during the simulation
  /t       mm /events get /times get cva dt mul def
  /sim_g_1 mm /events get /g_1   get cva def
  /sim_g_2 mm /events get /g_2   get cva def
  /sim_g_3 mm /events get /g_3   get cva def
  /sim_g_4 mm /events get /g_4   get cva def
  /sim_gs [sim_g_1 sim_g_2 sim_g_3 sim_g_4] def

  true
  [delays weights tau_rise tau_decay sim_gs]
  {
    /sim_g  exch def
    /tau2   exch def
    /tau1   exch def
    /W      exch def
    /t0     exch spike_time add def
    /theo_g t0 W tau2 tau1 t beta_function def
    sim_g theo_g sub { abs } Map Max tolerance leq and
  } ScanThread
}
assert_or_die

endusing
