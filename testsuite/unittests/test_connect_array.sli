/*
 *  test_connect_array.sli
 *
 *  This file is part of NEST.
 *
 *  Copyright (C) 2004 The NEST Initiative
 *
 *  NEST is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  NEST is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with NEST.  If not, see <http://www.gnu.org/licenses/>.
 *
 */


/* BeginDocumentation
   Name: testsuite::test_connect_array - SLI script to test connection with rules fixed_indegree or fixed_outdegree and parameter arrays in syn_spec

   Synopsis: (test_connect_array) run

   Description:

   Tests the possibility to use parameter arrays to define connection weights
   and/or delays in conjunction with the connection rules fixed_indegree and
   fixed_outdegree

   FirstVersion: August 2016
   Author: Bruno Golosio
   SeeAlso: Connect
 */

(unittest) run
/unittest using


/N    10  def    % number of neurons in each subnet
/K    3  def     % number of connections per neuron
%/N_VP 4    def  % number of virtual processes

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test with connection rule fixed_indegree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ResetKernel
% 0 << /total_num_virtual_procs N_VP >> SetStatus

/gid1 N 1 add def            % gid1 = N + 1
/gid2 N 2 mul def            % gid2 = N * 2
/net1 [1 N] Range def        % global ids of source subnet
/net2 [gid1 gid2] Range def  % global ids of target subnet

/iaf_neuron N Create  % creates source subnet 
/iaf_neuron N Create  % creates target subnet 

/NC N K mul def     % number of connections
/Dmax NC 1 add def  % maximum delay

/Warr [1 NC] Range cv_dv def    % weight array Warr=[1, ..., NC]
/Darr [2 Dmax] Range cv_dv def  % delay array  Darr=[2, ..., NC+1]
% cv_dv converts sli-array type to double-vector type

% synapses and connection dictionaries
/syn_dict << /model /static_synapse /weight Warr /delay Darr >> def
/conn_dict << /rule /fixed_indegree /indegree K >> def

net1 net2 conn_dict syn_dict Connect % connects source to target subnet

/Warr1 0 array def % creates empty weight array

net2 % loop on all neurons of target subnet
{
        /neuron2 exch def

        % gets all connections to the target neuron
        /conn << /target [neuron2] >> GetConnections def

        /sdict_lst conn GetSynapseStatus def % gets info on synapses

        /Warr2 0 array def % creates empty weight array

        sdict_lst % loop on synapses that connect to target neuron
        {
             /sdict exch def
             /w sdict /weight get def  % gets synaptic weight
             /d sdict /delay get def   % gets synaptic delay
             /diff d w sub def         % diff = delay - weight 
             diff 1.0 eq assert_or_die   % checks that delay = weight + 1

             /Warr2 Warr2 w append def  % appends w to Warr2
        } forall

        Warr2 size K eq assert_or_die % checks the size of Warr2
        /Warr2 Warr2 Sort def       % sorts the elements of Warr2
        /Warr1 Warr1 Warr2 join def  % joins Warr1 to Warr2
} forall

/Warr1 Warr1 [1 NC] Range sub def % Warr1 = Warr1 - [1,...,NC]

Warr1 {
        0.0 eq assert_or_die % checks the elements of Warr1
} forall

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% test with connection rule fixed_outdegree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ResetKernel
% 0 << /total_num_virtual_procs N_VP >> SetStatus

/gid1 N 1 add def            % gid1 = N + 1
/gid2 N 2 mul def            % gid2 = N * 2
/net1 [1 N] Range def        % global ids of source subnet
/net2 [gid1 gid2] Range def  % global ids of target subnet

/iaf_neuron N Create  % creates source subnet 
/iaf_neuron N Create  % creates target subnet 

/NC N K mul def     % number of connections
/Dmax NC 1 add def  % maximum delay

/Warr [1 NC] Range cv_dv def    % weight array Warr=[1, ..., NC]
/Darr [2 Dmax] Range cv_dv def  % delay array  Darr=[2, ..., NC+1]
% cv_dv converts sli-array type to double-vector type

% synapses and connection dictionaries
/syn_dict << /model /static_synapse /weight Warr /delay Darr >> def
/conn_dict << /rule /fixed_outdegree /outdegree K >> def

net1 net2 conn_dict syn_dict Connect % connects source to target subnet

/Warr1 0 array def % creates empty weight array

net1 % loop on all neurons of source subnet
{
        /neuron1 exch def

        % gets all connections from the source neuron
        /conn << /source [neuron1] >> GetConnections def

        /sdict_lst conn GetSynapseStatus def % gets info on synapses

        /Warr2 0 array def % creates empty weight array

        sdict_lst % loop on synapses that connect from source neuron
        {
             /sdict exch def
             /w sdict /weight get def  % gets synaptic weight
             /d sdict /delay get def   % gets synaptic delay
             /diff d w sub def         % diff = delay - weight 
             diff 1.0 eq assert_or_die   % checks that delay = weight + 1

             /Warr2 Warr2 w append def  % appends w to Warr2
        } forall

        Warr2 size K eq assert_or_die % checks the size of Warr2
        /Warr2 Warr2 Sort def       % sorts the elements of Warr2
        /Warr1 Warr1 Warr2 join def  % joins Warr1 to Warr2
} forall

/Warr1 Warr1 [1 NC] Range sub def % Warr1 = Warr1 - [1,...,NC]

Warr1 {
        0.0 eq assert_or_die % checks the elements of Warr1
} forall

